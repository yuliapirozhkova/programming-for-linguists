# Калькулятор

Использование стека, который является одной из самых простых и важных структур данных, можно
хорошо проиллюстрировать реализацией калькулятора. 

Калькулятор в привычной форме знаком каждому ещё со школы, и все мы знаем, что он работает по строгим математическим 
правилам. Но мало кто задумывался, как программы калькуляторы устроены внутри и каким образом 
они работают.

Реализация калькулятора позволит поработать с реализованным в лабораторных работах Стеком и написать
нетривиальные алгоритмы разбора и расчёта математических выражений.

Таким образом, для реализации данной работы убедитесь, что у вас есть:

0. Скачанный на свой компьютер репозиторий (если все еще нет - см. README в общей папке).
1. Понимание принципов LEGB, ООП.
2. Изученные файлы queue_.py и stack.py. Они на правах библиотек будут импортироваться в convert.py и
calculate.py

Далее рассмотрим базовые понятия - инфиксная и постфиксная записи математических выражений, принцип их реализации в
python для калькулятора.


## Инфиксная запись математических выражений
Все мы изучали математику и отлично знакомы с записью математических выражений. Простые операции сложения и умножения не 
вызывают вопросов:
```shell script
1 + 2
3 - 2.4
7 * 0.9
4 / 2
```  
Такую запись вида `операнд1 операция операнд2` называют инфиксной. Она признана во всём 
де-факто стандартом математическом виде. При появлении компьютеров и вычислении с их помощью математических вывражений
оказалось, что подобная запись неудобна для обработки компьютеру.

## Постфиксная запись
Для упрощения работы с математическими операциями в программах была изобретена постфиксная запись. Она упрощает запись 
выражения и тем самым позволяет построить простую программную структуру, вычисляющую значение выражения.

Привычные нам операции, где оператор распологается между операндами, принимает в постфиксной записи непонятный для нас
вид:
```shell script
a + b = ab+
3 + 2 = 23+
```

Но следование простым правилам чтения такой записи и её вычисления позволит без труда прочитать любое выражение,
записанное в постфиксной форме: "Порядок выполнения операций однозначно задаётся порядком следования знаков операций в
выражении".

У такой записи есть ещё одно преимущество перед инфиксной: скобки в постфиксной записи теряют свою актуальность, поскольку 
порядок выполнения операций становится очевидным из записи выражения.

Рассмотрим пример. Возьмём простейшее выражение, записаное в инфиксной форме, содержащее скобки:
```shell script
(1 + 2) * 3 # 9
```

Переведём данное выражение в постфиксную нотацию:

```shell script
12+3*
```

При чтении выражения первые две цифры - 1 и 2 - являются операндами оператора +. Результат работы этого оператора вместе с 
цифрой 3 являются операндами для оператора *. Это простейший пример постфиксной записи, показывающий рудиментарность скобок.
Операнды в данном примере идут в прямой последовательности слева направо. 

Рассмотрим пример, где порядок операндов и 
операций не такой тривиальный. Для этого необходимо скобочную группу в инфиксной записи переместить направо:
```shell script
3 * (1 + 2) # 9
```

Постфиксная запись данного выражения также изменится:
```shell script
312+*
```

Здесь первым оператором, так же как и в прошлом примере, является оператор `+`, его операнды - `1` и `2`. Вычислив значение 
этого оператора, получим: 
```shell script
33*
```
Это уже тривиальное выражение, значение которого подсчитать несложно.

## Перевод из инфиксной нотации в постфиксную
Тем не менее человеку воспринимать выражения в инфиксной нотации проще. Поэтому почти во всех калькуляторах на вход 
принимается выражение в инфиксной нотации, а уже программа переводит выражение в постфиксную нотацию. В связи с чем важную 
роль в реализации калькулятора играет алгоритм перевода из инфиксной нотации в постфиксную. В этом алгоритме 
используются реализованный ранее Стек. 

Рассмотрим этот алгоритм:

1. Пока есть ещё символы для чтения (особое внимание - данный алгоритм и нужно реализовать в основной функции при
конвертировании инфиксной записи в постфиксную (см. convert.py)):
    * Читаем очередной символ.
        * Если символ является открывающей скобкой, помещаем его в стек.
        * Если символ является закрывающей скобкой:
            * До тех пор, пока верхним элементом стека не станет открывающая скобка, выталкиваем элементы из стека в выходную 
    строку. При этом открывающая скобка удаляется из стека, но в выходную строку не добавляется. 
            * Если стек закончился раньше, чем мы встретили открывающую скобку, это означает, что в выражении либо неверно 
    поставлен разделитель, либо не согласованы скобки.
    * Если символ является бинарной операцией `O`, тогда:
        * пока на вершине стека префиксная функция…
        … ИЛИ операция на вершине стека приоритетнее `O`
        … ИЛИ операция на вершине стека левоассоциативная с приоритетом как у `O`
    … выталкиваем верхний элемент стека в выходную строку;
        * помещаем операцию `O` в стек.
2. Когда входная строка закончилась, выталкиваем все символы из стека в выходную строку.
В стеке должны были остаться только символы операций; если это не так, значит в выражении не согласованы скобки.
 
Этот алгоритм позволяет производить преобразование из инфиксной записи в постфиксную, следующий шаг - вычисление получившегося 
выражения в постфиксной записи.

## Вычисление на стеке выражения в постфиксной записи

Автоматизация вычисления выражений в обратной польской нотации основана на использовании стека. 
Алгоритм вычисления для стековой машины элементарен:
1. Обработка входного символа
    * Если на вход подан операнд, он помещается на вершину стека.
    * Если на вход подан знак операции, то соответствующая операция выполняется над требуемым количеством значений, 
    извлечённых из стека, взятых в порядке добавления. Результат выполненной операции кладётся на вершину стека.
    * Если входной набор символов обработан не полностью, перейти к шагу 1.
2. После полной обработки входного набора символов результат вычисления выражения лежит на вершине стека.
